# `add-modified` 功能的两种实现方案对比

## 背景

`quilt` 是一个补丁管理工具，而非完整的版本控制系统。其核心命令 `quilt diff` 和 `quilt refresh` 只能作用于通过 `quilt add` 明确告知它的文件。这导致在修改了大量文件（尤其是 `quilt` 未跟踪的文件）后，无法像 `git status` 那样自动发现所有改动并添加到补丁中，造成了工作流上的痛点。

为了解决这个问题，我们计划为脚本增加一个强大的 `add-modified` 命令，该命令可以自动化地扫描整个源码树，找出所有被修改过的文件，并自动将它们添加到当前的 `quilt` 补丁中。

以下是两种核心实现方案的详细对比。

---

## 方案 A: 坚持并优化 `quilt` 的原生工作流

这个方案不寻求“发明”新的全局差异检测机制，而是致力于优化和辅助 `quilt` 的标准工作流程。

### 核心思想

开发者依然遵循 `quilt` 的“先 `add`，后修改”的基本原则。脚本提供强大的辅助工具，让这个过程变得更简单、更不容易出错。

### 实现方式

脚本可以提供以下一个或多个命令：

1.  **`extract-files <commit_id>`**:
    *   **功能**: 从一个 `git` 的 `commit_id` 中自动提取所有涉及的文件列表，并保存到一个文本文件中。
    *   **工作流**: `extract-files <commit_id> -> add-files <file_list.txt>`。
    *   **状态**: **已实现**。

2.  **`add-from-patch <patch_file>`**:
    *   **功能**: 直接从一个本地的 `.patch` 文件中解析出所有涉及的文件，并自动 `quilt add` 它们。
    *   **工作流**: `add-from-patch a/b/c.patch`，一步到位。
    *   **实现**: 本质上是 `extract-files` 和 `add-files` 的结合体。

3.  **`interactive-add`**:
    *   **功能**: 启动一个交互式的界面（例如使用 `fzf`），让用户可以在文件树中快速、模糊地搜索并多选需要 `add` 的文件。
    *   **工作流**: 开发者在修改完代码后，凭记忆输入几个关键字，就能快速选中所有修改过的文件并一键添加。

### 优点

*   **简单、可靠**: 完全遵循 `quilt` 的设计哲学，不引入任何“黑科技”，没有复杂的依赖。
*   **低风险**: 不会意外修改 `quilt` 的内部状态，不易出错。
*   **实现成本低**: 大部分功能是现有命令的组合或简单扩展。

### 缺点

*   **未能完全自动化**: 仍然需要开发者的介入（无论是提供 commit_id，还是交互式选择）。当修改的文件与原始补丁无关且数量众多时，开发者可能会遗漏文件。
*   **无法解决“未知修改”**: 如果开发者修改了一个文件，但自己忘记了，这个方案无法自动发现它。

---

## 方案 B: 基于文件哈希清单的全局差异检测

这个方案旨在彻底解决 `quilt` 无法全局扫描的短板，为脚本引入一个类似 `git` 的、强大的全局状态感知能力。

### 核心思想

通过在修改前后分别对整个源码树的文件生成一份“指纹”清单（Manifest），然后通过比较这两份清单，精确地找出所有内容发生变化的文件。

### 实现方式

脚本将提供一个全新的 `add-modified` 命令，其内部工作流程如下：

1.  **`add-modified --create-snapshot` (或在 `quilt new` 时自动执行)**
    *   **触发时机**: 在一个干净的状态下（例如 `quilt pop -a` 之后，开始修改之前）。
    *   **执行动作**:
        *   递归地遍历整个内核源码目录 (`find . -type f`)。
        *   对找到的每一个文件，计算其 `md5` 或 `sha1` 哈希值。
        *   生成一个清单文件，例如 `patch_manager_work/snapshots/base_manifest.txt`。文件格式为：`<file_path>  <hash>`。
    *   **目的**: 创建一个源码树在修改前的“原始快照”。

2.  **`add-modified --run`**
    *   **触发时机**: 在开发者完成所有文件修改之后。
    *   **执行动作**:
        *   再次递归遍历源码目录，以同样的方式生成一份**当前**的清单文件 `patch_manager_work/snapshots/current_manifest.txt`。
        *   使用 `diff` 或 `grep -Fxvf` 等高效的文本比较工具，对比 `base_manifest.txt` 和 `current_manifest.txt`，找出所有哈希值发生变化的文件，以及新增的文件。
        *   将这些找出来的差异文件列表，通过管道传递给 `xargs quilt add` 或使用循环来批量添加。
    *   **目的**: 自动、精确地将所有被修改或新增的文件添加到当前 `quilt` 补丁中。

### 优点

*   **完全自动化，功能极其强大**: 彻底解决了手动添加的痛点。无论修改了多少文件，无论是否是 `quilt` 已知的文件，都能被精确捕捉。
*   **工作流革命性提升**: 用户体验无限接近 `git` 的 `git add .`。开发者可以随心所欲地修改，改完后一键添加所有改动。
*   **可靠性高**: 基于文件内容的哈希值比较，结果精确无误。

### 缺点

*   **实现复杂**: 需要处理文件遍历、哈希计算、文本比较、状态管理（如何以及何时创建快照）等逻辑，代码量和复杂性会显著增加。
*   **性能开销**: 对整个内核源码树（数万个文件）进行遍历和哈希计算，可能会有秒级的性能开销，尤其是在机械硬盘上。尽管可以接受，但不如方案 A 轻快。
*   **需要管理状态**: 脚本需要一个机制来存储和管理“原始快照”，并确保在正确的时机创建它（例如，在 `quilt new` 一个新补丁时）。

## 结论与建议

*   **方案 A** 是一个**务实、渐进**的改进，它能有效缓解当前工作流的痛点，且实现简单、风险低。
*   **方案 B** 是一个**雄心勃勃、革命性**的增强，它能从根本上解决 `quilt` 的核心短板，让脚本的可用性提升一个量级，但实现起来也更具挑战性。

**建议**:
可以分两步走。首先，快速实现**方案 A** 中的 `add-from-patch` 功能，因为它能解决最常见的场景，且成本最低。然后，如果用户反馈依然存在痛点，再将**方案 B** 作为下一个里程碑目标，投入资源进行开发。
