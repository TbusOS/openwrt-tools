# Kernel Snapshot 工具 - 快速开始示例

## 🚀 5分钟快速上手

### 第一步：准备工具和配置

```bash
# 1. 确保工具编译完成
cd /path/to/kernel_snapshot_tool
make clean && make

# 2. 创建全局配置文件（推荐方式）
cat > .kernel_snapshot.conf << 'EOF'
# 默认工作目录（改为你的实际路径）
default_workspace_dir=/home/user/linux-kernel-6.6

# 默认项目名称
default_project_name=linux-dev

# 忽略文件模式
ignore_patterns=.git,.snapshot,*.tmp,*.log,*.bak,*.o,*.ko,build/
EOF

# 3. 验证配置
./kernel_snapshot --help | grep -A 10 "全局配置文件"
```

### 第二步：创建第一个快照

```bash
# 方式 1：使用配置文件（推荐）
./kernel_snapshot create
# 输出示例：
# 📖 读取全局配置文件: ./.kernel_snapshot.conf
# 🔧 使用全局配置的默认工作目录: /home/user/linux-kernel-6.6
# 🔧 使用全局配置的默认项目名: linux-dev
# 🎯 初始化工作区: linux-dev (目录: /home/user/linux-kernel-6.6)
# 🔍 开始创建基线快照: /home/user/linux-kernel-6.6
# 🔄 处理文件...
# 📊 [████████████████████████████████████████████████] 100.0% (15420/15420) 完成
# ✅ 快照创建完成!
# 📊 处理摘要: 15420/15420 文件 (100.0%), 耗时: 2340 ms

# 方式 2：手动指定（如果没有配置文件）
./kernel_snapshot create /path/to/your/project my-project
```

### 第三步：模拟开发场景

```bash
# 1. 切换到工作目录（如果使用了配置文件，工具已经在正确的目录工作）
cd /home/user/linux-kernel-6.6

# 2. 模拟一些代码修改
echo "// 新功能实现" >> drivers/gpu/drm/new_feature.c
echo "新的配置选项" >> kernel/Kconfig.new
echo "临时调试信息" >> debug.tmp

# 3. 查看变更
/path/to/kernel_snapshot_tool/kernel_snapshot status
# 输出示例：
# 🔍 检查工作区状态 (基于基线快照)
# 🚀 Git风格快速状态检查 (使用索引缓存)...
# ✅ 索引载入完成，包含 15420 个文件
# 🔍 开始快速扫描...
# 
# 🔍 差异分析报告:
# ================
# 
# 🆕 新增的文件:
# A       drivers/gpu/drm/new_feature.c
# A       kernel/Kconfig.new
# 
# 📊 状态检查完成!
# ================
# 🧮 哈希计算: 0 (仅 0.0% 的文件)
# 
# 📈 变更统计:
#   🆕 新增文件: 2
#   ✏️  修改文件: 0
#   🗑️  删除文件: 0
#   ✅ 未变更: 15420
#   📊 总变更: 2
```

注意：`debug.tmp` 文件没有显示，因为它被配置文件中的 `*.tmp` 模式忽略了！

## 📋 完整的开发工作流示例

### 场景：Linux 内核驱动开发

```bash
# ===== 环境准备 =====
cd /usr/src/linux-6.6

# 创建针对内核开发的配置文件
cat > /path/to/kernel_snapshot_tool/.kernel_snapshot.conf << 'EOF'
default_workspace_dir=/usr/src/linux-6.6
default_project_name=kernel-6.6-driver-dev
ignore_patterns=.git,.snapshot,*.o,*.ko,*.mod.c,*.tmp,*.log,*.bak,build/,scripts/kconfig/.tmp*,vmlinux*,System.map,Module.symvers
EOF

# ===== 第一步：创建基线 =====
echo "🔄 步骤 1: 创建干净的基线快照..."
/path/to/kernel_snapshot_tool/kernel_snapshot create

# ===== 第二步：开始开发 =====
echo "🔄 步骤 2: 开始驱动开发..."

# 创建新的驱动文件
mkdir -p drivers/custom
cat > drivers/custom/my_driver.c << 'EOF'
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>

static int __init my_driver_init(void)
{
    printk(KERN_INFO "My driver loaded\n");
    return 0;
}

static void __exit my_driver_exit(void)
{
    printk(KERN_INFO "My driver unloaded\n");
}

module_init(my_driver_init);
module_exit(my_driver_exit);
MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("My Custom Driver");
EOF

# 修改 Kconfig 添加配置选项
cat >> drivers/custom/Kconfig << 'EOF'
config MY_CUSTOM_DRIVER
    tristate "My Custom Driver"
    help
      This is my custom driver for demonstration.
EOF

# 修改 Makefile
cat > drivers/custom/Makefile << 'EOF'
obj-$(CONFIG_MY_CUSTOM_DRIVER) += my_driver.o
EOF

# 更新上级 Makefile
echo "obj-\$(CONFIG_MY_CUSTOM_DRIVER) += custom/" >> drivers/Makefile

# ===== 第三步：检查变更 =====
echo "🔄 步骤 3: 检查开发进度..."
/path/to/kernel_snapshot_tool/kernel_snapshot status

# 预期输出：
# 🆕 新增的文件:
# A       drivers/custom/my_driver.c
# A       drivers/custom/Kconfig  
# A       drivers/custom/Makefile
# 
# 📝 修改的文件:
# M       drivers/Makefile

# ===== 第四步：编译测试 =====
echo "🔄 步骤 4: 编译测试..."
make oldconfig
make drivers/custom/my_driver.ko

# ===== 第五步：检查编译产物 =====
echo "🔄 步骤 5: 检查编译后的状态..."
/path/to/kernel_snapshot_tool/kernel_snapshot status

# 注意：编译产物（*.o, *.ko 等）不会显示，因为被忽略了
# 只会看到源码级别的变更

# ===== 第六步：继续开发 =====
echo "🔄 步骤 6: 添加更多功能..."

# 添加设备文件操作
cat >> drivers/custom/my_driver.c << 'EOF'

#include <linux/fs.h>
#include <linux/device.h>
#include <linux/cdev.h>

static dev_t dev_num;
static struct class *my_class;
static struct device *my_device;
static struct cdev my_cdev;

static int my_open(struct inode *inode, struct file *file)
{
    printk(KERN_INFO "Device opened\n");
    return 0;
}

static int my_release(struct inode *inode, struct file *file)
{
    printk(KERN_INFO "Device closed\n");
    return 0;
}

static const struct file_operations my_fops = {
    .owner = THIS_MODULE,
    .open = my_open,
    .release = my_release,
};
EOF

# ===== 第七步：最终检查 =====
echo "🔄 步骤 7: 最终开发状态检查..."
/path/to/kernel_snapshot_tool/kernel_snapshot status

# 最终输出示例：
# 🔍 差异分析报告:
# ================
# 
# 🆕 新增的文件:
# A       drivers/custom/my_driver.c
# A       drivers/custom/Kconfig
# A       drivers/custom/Makefile
# 
# 📝 修改的文件:
# M       drivers/Makefile
# 
# 📊 状态检查完成!
# ================
# 📈 变更统计:
#   🆕 新增文件: 3
#   ✏️  修改文件: 1
#   🗑️  删除文件: 0
#   ✅ 未变更: 67234
#   📊 总变更: 4

echo "✅ 开发完成！成功跟踪了所有源码级别的变更。"
```

## 🔧 常用操作示例

### 示例 1：快速切换项目

```bash
#!/bin/bash
# 项目切换脚本

switch_project() {
    case "$1" in
        "kernel")
            cat > .kernel_snapshot.conf << 'EOF'
default_workspace_dir=/usr/src/linux-6.6
default_project_name=kernel-dev
ignore_patterns=.git,.snapshot,*.o,*.ko,*.tmp,*.log,build/
EOF
            ;;
        "uboot")
            cat > .kernel_snapshot.conf << 'EOF'
default_workspace_dir=/home/user/u-boot
default_project_name=uboot-dev
ignore_patterns=.git,.snapshot,*.o,*.bin,*.elf,*.tmp,*.log
EOF
            ;;
        "openwrt")
            cat > .kernel_snapshot.conf << 'EOF'
default_workspace_dir=/home/user/openwrt
default_project_name=openwrt-dev
ignore_patterns=.git,.snapshot,build_dir/,staging_dir/,tmp/,*.tmp,*.log
EOF
            ;;
        *)
            echo "用法: switch_project [kernel|uboot|openwrt]"
            return 1
            ;;
    esac
    echo "✅ 已切换到 $1 项目配置"
    echo "📋 当前配置："
    cat .kernel_snapshot.conf
}

# 使用示例
switch_project kernel
./kernel_snapshot create

switch_project openwrt
./kernel_snapshot create
```

### 示例 2：自动化验证脚本

```bash
#!/bin/bash
# 补丁验证脚本

set -e

PATCH_FILE="$1"
if [[ -z "$PATCH_FILE" ]]; then
    echo "用法: $0 <补丁文件>"
    exit 1
fi

echo "🔄 开始补丁验证流程..."

# 1. 创建基线
echo "📸 创建应用补丁前的基线..."
./kernel_snapshot create patch-test-baseline

# 2. 应用补丁
echo "📝 应用补丁: $PATCH_FILE"
patch -p1 < "$PATCH_FILE"

# 3. 检查影响范围
echo "🔍 分析补丁影响范围..."
CHANGES_OUTPUT=$(./kernel_snapshot status)
echo "$CHANGES_OUTPUT"

# 4. 统计变更
MODIFIED_COUNT=$(echo "$CHANGES_OUTPUT" | grep -c "^M" || true)
ADDED_COUNT=$(echo "$CHANGES_OUTPUT" | grep -c "^A" || true)
DELETED_COUNT=$(echo "$CHANGES_OUTPUT" | grep -c "^D" || true)

echo ""
echo "📊 补丁影响统计："
echo "   修改文件: $MODIFIED_COUNT"
echo "   新增文件: $ADDED_COUNT"  
echo "   删除文件: $DELETED_COUNT"

# 5. 安全检查
TOTAL_CHANGES=$((MODIFIED_COUNT + ADDED_COUNT + DELETED_COUNT))
if [[ $TOTAL_CHANGES -gt 50 ]]; then
    echo "⚠️  警告：变更文件过多 ($TOTAL_CHANGES 个)，请仔细检查"
elif [[ $TOTAL_CHANGES -eq 0 ]]; then
    echo "⚠️  警告：补丁似乎没有产生任何变更"
else
    echo "✅ 变更范围合理 ($TOTAL_CHANGES 个文件)"
fi

# 6. 编译测试
echo "🔨 开始编译测试..."
if make -j$(nproc) > build.log 2>&1; then
    echo "✅ 编译成功"
else
    echo "❌ 编译失败，请查看 build.log"
    exit 1
fi

echo "🎉 补丁验证完成！"
```

### 示例 3：性能测试脚本

```bash
#!/bin/bash
# 性能测试脚本

echo "📊 Kernel Snapshot 性能测试"
echo "=========================="

# 测试不同大小的项目
test_performance() {
    local project_name="$1"
    local project_path="$2"
    
    echo ""
    echo "🔄 测试项目: $project_name"
    echo "📁 路径: $project_path"
    
    # 统计文件数量
    FILE_COUNT=$(find "$project_path" -type f | wc -l)
    echo "📋 文件总数: $FILE_COUNT"
    
    # 测试创建快照
    echo "⏱️  测试快照创建..."
    START_TIME=$(date +%s.%N)
    ./kernel_snapshot create "$project_path" "perf-test-$project_name"
    END_TIME=$(date +%s.%N)
    CREATE_TIME=$(echo "$END_TIME - $START_TIME" | bc)
    echo "   ⏱️  创建时间: ${CREATE_TIME}s"
    
    # 测试状态检查
    echo "⏱️  测试状态检查..."
    START_TIME=$(date +%s.%N)
    ./kernel_snapshot status > /dev/null
    END_TIME=$(date +%s.%N)
    STATUS_TIME=$(echo "$END_TIME - $START_TIME" | bc)
    echo "   ⏱️  状态检查时间: ${STATUS_TIME}s"
    
    # 计算性能指标
    if (( $(echo "$CREATE_TIME > 0" | bc -l) )); then
        CREATE_RATE=$(echo "scale=2; $FILE_COUNT / $CREATE_TIME" | bc)
        echo "   📈 创建速度: ${CREATE_RATE} 文件/秒"
    fi
    
    if (( $(echo "$STATUS_TIME > 0" | bc -l) )); then
        STATUS_RATE=$(echo "scale=2; $FILE_COUNT / $STATUS_TIME" | bc)
        echo "   📈 检查速度: ${STATUS_RATE} 文件/秒"
    fi
}

# 运行测试
test_performance "small" "/usr/include"
test_performance "medium" "/usr/src/linux-headers-$(uname -r)"
test_performance "large" "/usr/src/linux-6.6"

echo ""
echo "✅ 性能测试完成！"
```

## 🎯 总结

通过这些示例，你已经学会了：

1. **基本配置**：创建和使用全局配置文件
2. **开发工作流**：从创建基线到跟踪变更的完整流程
3. **高级用法**：项目切换、自动化验证、性能测试
4. **最佳实践**：合理的忽略模式和工作流集成

立即开始使用 Kernel Snapshot 工具，体验高效的内核开发！🚀

## 📞 获取帮助

```bash
# 查看完整帮助信息
./kernel_snapshot --help

# 查看版本信息
./kernel_snapshot --version

# 使用详细模式进行调试
./kernel_snapshot -v create
./kernel_snapshot -v status
```

如果遇到问题，请检查：
1. 配置文件路径和格式
2. 工作目录权限
3. 忽略模式语法
4. 文件系统空间