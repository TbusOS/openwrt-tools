#include "file_monitor.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <signal.h>
#include <fnmatch.h>
#include <sys/stat.h>

// ÂÖ®Â±ÄÁä∂ÊÄÅ
static volatile int g_monitor_running = 0;
static watch_stats_t *g_stats = NULL;

// ‰ø°Âè∑Â§ÑÁêÜ
static void signal_handler(int sig) {
    (void)sig;
    g_monitor_running = 0;
    printf("\nüõë ÁõëÊéßÂ∑≤ÂÅúÊ≠¢\n");
}

// Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â∫îËØ•Ë¢´ÂøΩÁï•
static int should_ignore_file(const char *path, const char *patterns) {
    if (!patterns || !path) return 0;
    
    char patterns_copy[1024];
    strncpy(patterns_copy, patterns, sizeof(patterns_copy) - 1);
    patterns_copy[sizeof(patterns_copy) - 1] = '\0';
    
    char *pattern = strtok(patterns_copy, ",");
    while (pattern) {
        // ÂéªÈô§Á©∫Ê†º
        while (*pattern == ' ') pattern++;
        char *end = pattern + strlen(pattern) - 1;
        while (end > pattern && *end == ' ') *end-- = '\0';
        
        if (fnmatch(pattern, path, FNM_PATHNAME | FNM_PERIOD) == 0) {
            return 1;
        }
        pattern = strtok(NULL, ",");
    }
    return 0;
}

// Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥Êà≥ÔºàÊØ´ÁßíÔºâ
uint64_t get_current_timestamp_ms(void) {
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (uint64_t)ts.tv_sec * 1000 + ts.tv_nsec / 1000000;
}

// Ê†ºÂºèÂåñÊó∂Èó¥Â≠óÁ¨¶‰∏≤
static void format_time_string(char *buffer, size_t size) {
    time_t now = time(NULL);
    struct tm *tm_info = localtime(&now);
    strftime(buffer, size, "%H:%M:%S", tm_info);
}

// Êõ¥Êñ∞ÁªüËÆ°‰ø°ÊÅØ
static void update_stats(file_event_type_t type) {
    if (!g_stats) return;
    
    switch (type) {
        case FILE_EVENT_CREATED:
            g_stats->created_count++;
            break;
        case FILE_EVENT_MODIFIED:
            g_stats->modified_count++;
            break;
        case FILE_EVENT_DELETED:
            g_stats->deleted_count++;
            break;
        case FILE_EVENT_MOVED:
            g_stats->moved_count++;
            break;
    }
    g_stats->last_event_time = get_current_timestamp_ms();
}

// ÈªòËÆ§‰∫ã‰ª∂Â§ÑÁêÜÂõûË∞É
static void default_event_callback(const file_event_t *event, void *user_data) {
    watch_config_t *config = (watch_config_t *)user_data;
    
    // ËÆ°ÁÆóÁõ∏ÂØπË∑ØÂæÑÊòæÁ§∫
    const char *display_path = event->path;
    
    // Â∞ùËØïËé∑ÂèñÁõëÊéßÁõÆÂΩïÁöÑÁªùÂØπË∑ØÂæÑËøõË°åÊØîËæÉ
    char abs_monitor_dir[MAX_PATH_LEN];
    if (realpath(config->monitor_dir, abs_monitor_dir) != NULL) {
        size_t abs_dir_len = strlen(abs_monitor_dir);
        if (strncmp(event->path, abs_monitor_dir, abs_dir_len) == 0) {
            // Â¶ÇÊûú‰∫ã‰ª∂Ë∑ØÂæÑ‰ª•ÁõëÊéßÁõÆÂΩïÂºÄÂ§¥ÔºåÊòæÁ§∫Áõ∏ÂØπË∑ØÂæÑ
            display_path = event->path + abs_dir_len;
            if (display_path[0] == '/') display_path++; // Ë∑≥ËøáÂºÄÂ§¥ÁöÑÊñúÊù†
            if (display_path[0] == '\0') display_path = "."; // Â¶ÇÊûúÊòØÊ†πÁõÆÂΩïÊú¨Ë∫´
        }
    }
    
    // Ê£ÄÊü•ÂøΩÁï•ËßÑÂàô
    if (should_ignore_file(event->path, config->ignore_patterns)) {
        return;
    }
    
    char time_str[32];
    format_time_string(time_str, sizeof(time_str));
    
    const char *emoji, *action;
    switch (event->type) {
        case FILE_EVENT_CREATED:
            emoji = "üÜï"; action = "ADDED   ";
            break;
        case FILE_EVENT_MODIFIED:
            emoji = "üìù"; action = "MODIFIED";
            break;
        case FILE_EVENT_DELETED:
            emoji = "üóëÔ∏è "; action = "DELETED ";
            break;
        case FILE_EVENT_MOVED:
            emoji = "üì¶"; action = "MOVED   ";
            break;
        default:
            emoji = "‚ùì"; action = "UNKNOWN ";
            break;
    }
    
    if (config->verbose && event->file_size > 0) {
        printf("[%s] %s %s %s (%zu bytes)\n", 
               time_str, emoji, action, display_path, event->file_size);
    } else {
        printf("[%s] %s %s %s\n", 
               time_str, emoji, action, display_path);
    }
    
    update_stats(event->type);
}

#ifdef __APPLE__
// ==================== macOS ÂÆûÁé∞ (FSEvents) ====================
#include <CoreServices/CoreServices.h>

static FSEventStreamRef g_stream = NULL;
static CFRunLoopRef g_run_loop = NULL;

void fsevents_callback(ConstFSEventStreamRef streamRef,
                      void *clientCallBackInfo,
                      size_t numEvents,
                      void *eventPaths,
                      const FSEventStreamEventFlags eventFlags[],
                      const FSEventStreamEventId eventIds[]) {
    (void)streamRef;
    (void)eventIds;
    
    char **paths = (char **)eventPaths;
    watch_config_t *config = (watch_config_t *)clientCallBackInfo;
    
    for (size_t i = 0; i < numEvents; i++) {
        file_event_t event = {0};
        strncpy(event.path, paths[i], sizeof(event.path) - 1);
        event.timestamp = get_current_timestamp_ms();
        
        // ÁÆÄÂåñÁöÑ‰∫ã‰ª∂Á±ªÂûãÂà§Êñ≠
        if (eventFlags[i] & kFSEventStreamEventFlagItemCreated) {
            event.type = FILE_EVENT_CREATED;
        } else if (eventFlags[i] & kFSEventStreamEventFlagItemModified) {
            event.type = FILE_EVENT_MODIFIED;
        } else if (eventFlags[i] & kFSEventStreamEventFlagItemRemoved) {
            event.type = FILE_EVENT_DELETED;
        } else if (eventFlags[i] & kFSEventStreamEventFlagItemRenamed) {
            event.type = FILE_EVENT_MOVED;
        } else {
            event.type = FILE_EVENT_MODIFIED; // ÈªòËÆ§‰∏∫‰øÆÊîπ
        }
        
        // Ëé∑ÂèñÊñá‰ª∂Â§ßÂ∞è
        struct stat st;
        if (stat(event.path, &st) == 0) {
            event.file_size = st.st_size;
        }
        
        if (config->callback) {
            config->callback(&event, config->user_data);
        }
    }
}

int file_monitor_start(const watch_config_t *config, watch_stats_t *stats) {
    if (!config || !config->monitor_dir[0]) {
        fprintf(stderr, "ÈîôËØØ: Êó†ÊïàÁöÑÁõëÊéßÈÖçÁΩÆ\n");
        return -1;
    }
    
    g_stats = stats;
    if (g_stats) {
        memset(g_stats, 0, sizeof(watch_stats_t));
        g_stats->start_time = get_current_timestamp_ms();
    }
    
    printf("üëÄ [macOS] ÂºÄÂßãÁõëÊéßÁõÆÂΩï: %s\n", config->monitor_dir);
    printf("    Êû∂ÊûÑ: %s\n", 
#ifdef __x86_64__
           "Intel x86_64"
#elif defined(__arm64__)
           "Apple Silicon ARM64"
#else
           "Unknown"
#endif
    );
    printf("    (Êåâ Ctrl+C ÂÅúÊ≠¢ÁõëÊéß)\n\n");
    
    // ËÆæÁΩÆ‰ø°Âè∑Â§ÑÁêÜ
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    
    CFStringRef path = CFStringCreateWithCString(NULL, config->monitor_dir, kCFStringEncodingUTF8);
    CFArrayRef pathsToWatch = CFArrayCreate(NULL, (const void **)&path, 1, NULL);
    
    FSEventStreamContext context = {0, (void*)config, NULL, NULL, NULL};
    
    g_stream = FSEventStreamCreate(
        NULL,
        &fsevents_callback,
        &context,
        pathsToWatch,
        kFSEventStreamEventIdSinceNow,
        1.0, // Âª∂Ëøü
        kFSEventStreamCreateFlagFileEvents  // ÁßªÈô§ UseCFTypes Ê†áÂøó
    );
    
    if (!g_stream) {
        fprintf(stderr, "ÈîôËØØ: Êó†Ê≥ïÂàõÂª∫ FSEvent ÊµÅ\n");
        CFRelease(path);
        CFRelease(pathsToWatch);
        return -1;
    }
    
    g_run_loop = CFRunLoopGetCurrent();
    FSEventStreamScheduleWithRunLoop(g_stream, g_run_loop, kCFRunLoopDefaultMode);
    FSEventStreamStart(g_stream);
    
    g_monitor_running = 1;
    
    // ËøêË°å‰∫ã‰ª∂Âæ™ÁéØ
    while (g_monitor_running) {
        CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.1, false);
        
        // ÂÆöÊúüÊòæÁ§∫ÁªüËÆ°‰ø°ÊÅØ
        if (config->show_stats && config->stats_interval > 0) {
            static time_t last_stats_time = 0;
            time_t now = time(NULL);
            if (now - last_stats_time >= config->stats_interval) {
                if (g_stats) {
                    printf("\rüìä ÂàõÂª∫:%llu ‰øÆÊîπ:%llu Âà†Èô§:%llu ÁßªÂä®:%llu",
                           g_stats->created_count, g_stats->modified_count,
                           g_stats->deleted_count, g_stats->moved_count);
                    fflush(stdout);
                }
                last_stats_time = now;
            }
        }
    }
    
    // Ê∏ÖÁêÜ
    FSEventStreamStop(g_stream);
    FSEventStreamInvalidate(g_stream);
    FSEventStreamRelease(g_stream);
    CFRelease(path);
    CFRelease(pathsToWatch);
    
    g_stream = NULL;
    g_run_loop = NULL;
    
    return 0;
}

void file_monitor_stop(void) {
    g_monitor_running = 0;
    if (g_run_loop) {
        CFRunLoopStop(g_run_loop);
    }
}

int file_monitor_is_supported(void) {
    return 1; // macOS ÊÄªÊòØÊîØÊåÅ FSEvents
}

const char* file_monitor_get_platform_name(void) {
#ifdef __x86_64__
    return "macOS Intel x86_64";
#elif defined(__arm64__)
    return "macOS Apple Silicon ARM64";
#else
    return "macOS Unknown Architecture";
#endif
}

#elif defined(__linux__)
// ==================== Linux ÂÆûÁé∞ (inotify) ====================
#include <sys/inotify.h>
#include <limits.h>
#include <dirent.h>

#define MAX_WATCH_DIRS 1024
#define EVENT_SIZE (sizeof(struct inotify_event))
#define BUF_LEN (1024 * (EVENT_SIZE + 16))
#define EVENT_DEDUP_WINDOW_MS 500  // ‰∫ã‰ª∂ÂéªÈáçÊó∂Èó¥Á™óÂè£Ôºö500ÊØ´ÁßíÔºàÊõ¥ÈïøÁöÑÁ™óÂè£Â§ÑÁêÜCREATE+CLOSE_WRITEÁªÑÂêàÔºâ

static int g_inotify_fd = -1;
static int g_watch_descriptors[MAX_WATCH_DIRS];
static char g_watch_paths[MAX_WATCH_DIRS][MAX_PATH_LEN];
static int g_watch_count = 0;

// ‰∫ã‰ª∂ÂéªÈáçÁªìÊûÑ
typedef struct recent_event {
    char path[MAX_PATH_LEN];
    file_event_type_t type;
    uint64_t timestamp;
    struct recent_event *next;
} recent_event_t;

static recent_event_t *g_recent_events = NULL;

// Ê∏ÖÁêÜËøáÊúüÁöÑ‰∫ã‰ª∂ËÆ∞ÂΩï
static void cleanup_expired_events(uint64_t current_time) {
    recent_event_t **current = &g_recent_events;
    while (*current) {
        if (current_time - (*current)->timestamp > EVENT_DEDUP_WINDOW_MS) {
            recent_event_t *to_delete = *current;
            *current = (*current)->next;
            free(to_delete);
        } else {
            current = &((*current)->next);
        }
    }
}

// Ê£ÄÊü•ÊòØÂê¶‰∏∫ÈáçÂ§ç‰∫ã‰ª∂
static int is_duplicate_event(const char *path, file_event_type_t type, uint64_t timestamp) {
    cleanup_expired_events(timestamp);
    
    recent_event_t *current = g_recent_events;
    while (current) {
        if (current->type == type && 
            strcmp(current->path, path) == 0 &&
            (timestamp - current->timestamp) <= EVENT_DEDUP_WINDOW_MS) {
            return 1; // ÊòØÈáçÂ§ç‰∫ã‰ª∂
        }
        current = current->next;
    }
    return 0; // ‰∏çÊòØÈáçÂ§ç‰∫ã‰ª∂
}

// ËÆ∞ÂΩïÊñ∞‰∫ã‰ª∂
static void record_event(const char *path, file_event_type_t type, uint64_t timestamp) {
    recent_event_t *new_event = malloc(sizeof(recent_event_t));
    if (!new_event) return;
    
    strncpy(new_event->path, path, sizeof(new_event->path) - 1);
    new_event->path[sizeof(new_event->path) - 1] = '\0';
    new_event->type = type;
    new_event->timestamp = timestamp;
    new_event->next = g_recent_events;
    g_recent_events = new_event;
}

// Ê∏ÖÁêÜÊâÄÊúâ‰∫ã‰ª∂ËÆ∞ÂΩï
static void cleanup_all_events(void) {
    while (g_recent_events) {
        recent_event_t *to_delete = g_recent_events;
        g_recent_events = g_recent_events->next;
        free(to_delete);
    }
}

// ÈÄíÂΩíÊ∑ªÂä†ÁõÆÂΩïÁõëÊéß
static int add_watch_recursive(int fd, const char *path, const watch_config_t *config) {
    if (g_watch_count >= MAX_WATCH_DIRS) {
        fprintf(stderr, "Ë≠¶Âëä: Â∑≤ËææÂà∞ÊúÄÂ§ßÁõëÊéßÁõÆÂΩïÊï∞Èáè %d\n", MAX_WATCH_DIRS);
        return -1;
    }
    
    int wd = inotify_add_watch(fd, path, 
                               IN_CREATE | IN_MODIFY | IN_DELETE | 
                               IN_MOVED_FROM | IN_MOVED_TO | IN_CLOSE_WRITE);
    if (wd == -1) {
        perror("inotify_add_watch");
        return -1;
    }
    
    g_watch_descriptors[g_watch_count] = wd;
    strncpy(g_watch_paths[g_watch_count], path, MAX_PATH_LEN - 1);
    g_watch_paths[g_watch_count][MAX_PATH_LEN - 1] = '\0';
    g_watch_count++;
    
    // ÈÄíÂΩíÂ§ÑÁêÜÂ≠êÁõÆÂΩï
    if (config->recursive) {
        DIR *dir = opendir(path);
        if (dir) {
            struct dirent *entry;
            while ((entry = readdir(dir)) != NULL) {
                if (entry->d_type == DT_DIR && 
                    strcmp(entry->d_name, ".") != 0 && 
                    strcmp(entry->d_name, "..") != 0) {
                    
                    char subdir[MAX_PATH_LEN];
                    snprintf(subdir, sizeof(subdir), "%s/%s", path, entry->d_name);
                    
                    // Ê£ÄÊü•ÊòØÂê¶Â∫îËØ•ÂøΩÁï•
                    if (!should_ignore_file(subdir, config->ignore_patterns)) {
                        add_watch_recursive(fd, subdir, config);
                    }
                }
            }
            closedir(dir);
        }
    }
    
    return 0;
}

// Ê†πÊçÆÁõëÊéßÊèèËø∞Á¨¶Êü•ÊâæË∑ØÂæÑ
static const char* find_watch_path(int wd) {
    for (int i = 0; i < g_watch_count; i++) {
        if (g_watch_descriptors[i] == wd) {
            return g_watch_paths[i];
        }
    }
    return NULL;
}

int file_monitor_start(const watch_config_t *config, watch_stats_t *stats) {
    if (!config || !config->monitor_dir[0]) {
        fprintf(stderr, "ÈîôËØØ: Êó†ÊïàÁöÑÁõëÊéßÈÖçÁΩÆ\n");
        return -1;
    }
    
    g_stats = stats;
    if (g_stats) {
        memset(g_stats, 0, sizeof(watch_stats_t));
        g_stats->start_time = get_current_timestamp_ms();
    }
    
    printf("üëÄ [Linux] ÂºÄÂßãÁõëÊéßÁõÆÂΩï: %s\n", config->monitor_dir);
    printf("    Êû∂ÊûÑ: %s\n",
#ifdef __x86_64__
           "x86_64"
#elif defined(__i386__)
           "x86 (32-bit)"
#elif defined(__aarch64__)
           "ARM64"
#elif defined(__arm__)
           "ARM32"
#elif defined(__mips__)
           "MIPS"
#elif defined(__riscv)
           "RISC-V"
#else
           "Unknown"
#endif
    );
    printf("    ÈÄíÂΩíÁõëÊéß: %s\n", config->recursive ? "ÊòØ" : "Âê¶");
    printf("    (Êåâ Ctrl+C ÂÅúÊ≠¢ÁõëÊéß)\n\n");
    
    // ËÆæÁΩÆ‰ø°Âè∑Â§ÑÁêÜ
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    
    g_inotify_fd = inotify_init();
    if (g_inotify_fd == -1) {
        perror("inotify_init");
        return -1;
    }
    
    g_watch_count = 0;
    if (add_watch_recursive(g_inotify_fd, config->monitor_dir, config) == -1) {
        close(g_inotify_fd);
        return -1;
    }
    
    printf("üìÅ ÁõëÊéß‰∫Ü %d ‰∏™ÁõÆÂΩï\n\n", g_watch_count);
    
    g_monitor_running = 1;
    char buffer[BUF_LEN];
    
    while (g_monitor_running) {
        fd_set fds;
        FD_ZERO(&fds);
        FD_SET(g_inotify_fd, &fds);
        
        struct timeval timeout = {1, 0}; // 1ÁßíË∂ÖÊó∂
        int ret = select(g_inotify_fd + 1, &fds, NULL, NULL, &timeout);
        
        if (ret == -1) {
            if (g_monitor_running) {
                perror("select");
            }
            break;
        } else if (ret == 0) {
            // Ë∂ÖÊó∂ÔºåÊ£ÄÊü•ÁªüËÆ°ÊòæÁ§∫
            if (config->show_stats && config->stats_interval > 0) {
                static time_t last_stats_time = 0;
                time_t now = time(NULL);
                if (now - last_stats_time >= config->stats_interval) {
                    if (g_stats) {
                        printf("\rüìä ÂàõÂª∫:%llu ‰øÆÊîπ:%llu Âà†Èô§:%llu ÁßªÂä®:%llu",
                               g_stats->created_count, g_stats->modified_count,
                               g_stats->deleted_count, g_stats->moved_count);
                        fflush(stdout);
                    }
                    last_stats_time = now;
                }
            }
            continue;
        }
        
        if (!FD_ISSET(g_inotify_fd, &fds)) {
            continue;
        }
        
        int length = read(g_inotify_fd, buffer, BUF_LEN);
        if (length <= 0) {
            if (g_monitor_running) {
                perror("read");
            }
            break;
        }
        
        int i = 0;
        while (i < length) {
            struct inotify_event *event = (struct inotify_event *)&buffer[i];
            
            if (event->len > 0) {
                const char *watch_path = find_watch_path(event->wd);
                if (watch_path) {
                    file_event_t file_event = {0};
                    snprintf(file_event.path, sizeof(file_event.path), 
                            "%s/%s", watch_path, event->name);
                    file_event.timestamp = get_current_timestamp_ms();
                    
                    // Êô∫ËÉΩ‰∫ã‰ª∂Âà§Êñ≠ - ÊØèÊ¨°Êìç‰ΩúÂè™ÊòæÁ§∫ÊúÄÁªàÁöÑ„ÄÅÊúÄÊúâÊÑè‰πâÁöÑ‰∫ã‰ª∂
                    int should_process = 1;
                    
                    if (event->mask & IN_DELETE || event->mask & IN_MOVED_FROM) {
                        // Êñá‰ª∂Âà†Èô§ - Á´ãÂç≥Â§ÑÁêÜÔºå‰ºòÂÖàÁ∫ßÊúÄÈ´ò
                        file_event.type = FILE_EVENT_DELETED;
                    } else if (event->mask & IN_CLOSE_WRITE) {
                        // Êñá‰ª∂ÂÜôÂÖ•ÂÆåÊàê - ËøôÊòØÊúÄÂèØÈù†ÁöÑ"Êìç‰ΩúÂÆåÊàê"ÊåáÁ§∫
                        struct stat st;
                        if (stat(file_event.path, &st) == 0) {
                            // Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶‰∏∫Á©∫ÊàñÂæàÂ∞èÔºå‰ª•ÂèäÊòØÂê¶ÊòØÊúÄËøëÂàõÂª∫ÁöÑ
                            recent_event_t *recent = g_recent_events;
                            int found_recent_create = 0;
                            uint64_t now = get_current_timestamp_ms();
                            
                            // Ê£ÄÊü•ÊúÄËøë500msÂÜÖÊòØÂê¶ÊúâÂêå‰∏ÄÊñá‰ª∂ÁöÑCREATE‰∫ã‰ª∂
                            while (recent) {
                                if (strcmp(recent->path, file_event.path) == 0 && 
                                    recent->type == FILE_EVENT_CREATED &&
                                    (now - recent->timestamp) <= EVENT_DEDUP_WINDOW_MS) {
                                    found_recent_create = 1;
                                    break;
                                }
                                recent = recent->next;
                            }
                            
                            if (found_recent_create) {
                                // ÊúÄËøëÂàöÂàõÂª∫ÁöÑÊñá‰ª∂ÔºåCLOSE_WRITEÊòØÂàõÂª∫Êìç‰ΩúÁöÑ‰∏ÄÈÉ®ÂàÜÔºåË∑≥Ëøá
                                should_process = 0;
                            } else {
                                // Â∑≤Â≠òÂú®Êñá‰ª∂ÁöÑ‰øÆÊîπÊìç‰Ωú
                                file_event.type = FILE_EVENT_MODIFIED;
                            }
                        } else {
                            // Êñá‰ª∂‰∏çÂ≠òÂú®‰∫ÜÔºåË∑≥Ëøá
                            should_process = 0;
                        }
                    } else if (event->mask & IN_CREATE) {
                        // Êñá‰ª∂ÂàõÂª∫ - Âè™Â§ÑÁêÜËøô‰∏™‰∫ã‰ª∂ÔºåÂøΩÁï•ÂêéÁª≠ÁöÑCLOSE_WRITE
                        file_event.type = FILE_EVENT_CREATED;
                    } else if (event->mask & IN_MOVED_TO) {
                        // Êñá‰ª∂ÁßªÂÖ• - ËßÜ‰∏∫ÂàõÂª∫
                        file_event.type = FILE_EVENT_CREATED;
                    } else {
                        // Ë∑≥ËøáÂÖ∂‰ªñÊâÄÊúâ‰∫ã‰ª∂ÔºàÂåÖÊã¨IN_MODIFYÔºâ
                        should_process = 0;
                    }
                    
                    // Âè™ÊúâÂΩìshould_process‰∏∫1Êó∂ÊâçÂ§ÑÁêÜ‰∫ã‰ª∂
                    if (should_process) {
                        // Ëé∑ÂèñÊñá‰ª∂Â§ßÂ∞è
                        if (file_event.type != FILE_EVENT_DELETED) {
                            struct stat st;
                            if (stat(file_event.path, &st) == 0) {
                                file_event.file_size = st.st_size;
                            }
                        }
                        
                        // ‰∫ã‰ª∂ÂéªÈáçÊ£ÄÊü•
                        if (!is_duplicate_event(file_event.path, file_event.type, file_event.timestamp)) {
                            record_event(file_event.path, file_event.type, file_event.timestamp);
                            
                            if (config->callback) {
                                config->callback(&file_event, config->user_data);
                            }
                        } else {
                            // Ë∞ÉËØï‰ø°ÊÅØÔºöÊòæÁ§∫Ë¢´ËøáÊª§ÁöÑÈáçÂ§ç‰∫ã‰ª∂
                            if (config->verbose) {
                                char time_str[32];
                                format_time_string(time_str, sizeof(time_str));
                                printf("[%s] üîÑ DUPLICATE %s (Â∑≤ËøáÊª§)\n", 
                                       time_str, file_event.path);
                            }
                        }
                    }
                }
            }
            
            i += EVENT_SIZE + event->len;
        }
    }
    
    // Ê∏ÖÁêÜ
    for (int i = 0; i < g_watch_count; i++) {
        inotify_rm_watch(g_inotify_fd, g_watch_descriptors[i]);
    }
    close(g_inotify_fd);
    g_inotify_fd = -1;
    g_watch_count = 0;
    
    // Ê∏ÖÁêÜ‰∫ã‰ª∂ÂéªÈáçËÆ∞ÂΩï
    cleanup_all_events();
    
    return 0;
}

void file_monitor_stop(void) {
    g_monitor_running = 0;
}

int file_monitor_is_supported(void) {
    return 1; // Linux ÊÄªÊòØÊîØÊåÅ inotify
}

const char* file_monitor_get_platform_name(void) {
    return "Linux ("
#ifdef __x86_64__
           "x86_64"
#elif defined(__i386__)
           "x86"
#elif defined(__aarch64__)
           "ARM64"
#elif defined(__arm__)
           "ARM32"
#elif defined(__mips__)
           "MIPS"
#elif defined(__riscv)
           "RISC-V"
#else
           "Unknown"
#endif
           ")";
}

#else
// ==================== ‰∏çÊîØÊåÅÁöÑÂπ≥Âè∞ ====================

int file_monitor_start(const watch_config_t *config, watch_stats_t *stats) {
    (void)config;
    (void)stats;
    fprintf(stderr, "ÈîôËØØ: ÂΩìÂâçÂπ≥Âè∞‰∏çÊîØÊåÅÊñá‰ª∂ÁõëÊéßÂäüËÉΩ\n");
    fprintf(stderr, "ÊîØÊåÅÁöÑÂπ≥Âè∞: Linux (x86_64/ARM32/ARM64), macOS (Intel/Apple Silicon)\n");
    return -1;
}

void file_monitor_stop(void) {
    // Á©∫ÂÆûÁé∞
}

int file_monitor_is_supported(void) {
    return 0;
}

const char* file_monitor_get_platform_name(void) {
    return "Unsupported Platform";
}

#endif

// ==================== ÈÄöÁî®ËæÖÂä©ÂáΩÊï∞ ====================

// ÂàõÂª∫ÈªòËÆ§ÁöÑ watch ÈÖçÁΩÆ
watch_config_t* create_default_watch_config(const char *monitor_dir) {
    watch_config_t *config = malloc(sizeof(watch_config_t));
    if (!config) return NULL;
    
    memset(config, 0, sizeof(watch_config_t));
    
    if (monitor_dir) {
        strncpy(config->monitor_dir, monitor_dir, sizeof(config->monitor_dir) - 1);
    } else {
        strncpy(config->monitor_dir, ".", sizeof(config->monitor_dir) - 1);
    }
    
    // ÈªòËÆ§ÂøΩÁï•Ê®°Âºè
    strncpy(config->ignore_patterns, 
            ".snapshot,*.o,*.so,*.a,*.tmp,*.log,*.bak,.git,node_modules,build,*.pyc",
            sizeof(config->ignore_patterns) - 1);
    
    config->recursive = 1;           // ÈªòËÆ§ÈÄíÂΩíÁõëÊéß
    config->verbose = 0;             // ÈªòËÆ§ÁÆÄÊ¥ÅËæìÂá∫
    config->show_stats = 0;          // ÈªòËÆ§‰∏çÊòæÁ§∫ÁªüËÆ°
    config->stats_interval = 10;     // 10ÁßíÈó¥Èöî
    config->callback = default_event_callback;
    config->user_data = config;      // ÂõûË∞É‰∏≠‰ΩøÁî®ÈÖçÁΩÆÊú¨Ë∫´
    
    return config;
}

// ÈîÄÊØÅ watch ÈÖçÁΩÆ
void destroy_watch_config(watch_config_t *config) {
    if (config) {
        free(config);
    }
} 